"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6141],{3905:(e,a,n)=>{n.d(a,{Zo:()=>c,kt:()=>m});var t=n(7294);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function s(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function o(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?s(Object(n),!0).forEach((function(a){r(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function i(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},s=Object.keys(e);for(t=0;t<s.length;t++)n=s[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(t=0;t<s.length;t++)n=s[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=t.createContext({}),h=function(e){var a=t.useContext(l),n=a;return e&&(n="function"==typeof e?e(a):o(o({},a),e)),n},c=function(e){var a=h(e.components);return t.createElement(l.Provider,{value:a},e.children)},d={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},u=t.forwardRef((function(e,a){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=h(n),m=r,p=u["".concat(l,".").concat(m)]||u[m]||d[m]||s;return n?t.createElement(p,o(o({ref:a},c),{},{components:n})):t.createElement(p,o({ref:a},c))}));function m(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=u;var i={};for(var l in a)hasOwnProperty.call(a,l)&&(i[l]=a[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var h=2;h<s;h++)o[h]=n[h];return t.createElement.apply(null,o)}return t.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5984:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>c,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>h,toc:()=>d});var t=n(7462),r=n(3366),s=(n(7294),n(3905)),o=["components"],i={},l=void 0,h={unversionedId:"learn/learn-comparisons-ethereum-2",id:"learn/learn-comparisons-ethereum-2",title:"learn-comparisons-ethereum-2",description:"Selendra",source:"@site/../docs/learn/learn-comparisons-ethereum-2.md",sourceDirName:"learn",slug:"/learn/learn-comparisons-ethereum-2",permalink:"/docs/learn/learn-comparisons-ethereum-2",draft:!1,editUrl:"https://github.com/selendra/selendra-wiki/edit/master/docs/learn/learn-comparisons-ethereum-2.md",tags:[],version:"current",lastUpdatedBy:"hangsiahong",lastUpdatedAt:1668761402,formattedLastUpdatedAt:"Nov 18, 2022",frontMatter:{},sidebar:"docs",previous:{title:"Other comparisons",permalink:"/docs/learn-comparisons"},next:{title:"Cosmos",permalink:"/docs/learn-comparisons-cosmos"}},c={},d=[{value:"slug: ../learn-comparisons-ethereum-2",id:"slug-learn-comparisons-ethereum-2",level:2},{value:"Model",id:"model",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Ethereum 2.0",id:"ethereum-20",level:3},{value:"Selendra",id:"selendra",level:3},{value:"Consensus",id:"consensus",level:2},{value:"Staking Mechanics",id:"staking-mechanics",level:2},{value:"Shards",id:"shards",level:2},{value:"Message Passing",id:"message-passing",level:2},{value:"Governance",id:"governance",level:2},{value:"Upgrades",id:"upgrades",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"References",id:"references",level:2}],u={toc:d};function m(e){var a=e.components,n=(0,r.Z)(e,o);return(0,s.kt)("wrapper",(0,t.Z)({},u,n,{components:a,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Selendra\nid: learn-comparisons-ethereum-2\ntitle: Selendra and Ethereum 2.0\nsidebar_label: Ethereum 2.0\ndescription: A high-level comparison between Selendra and Ethereum 2.0.\nkeywords: ","[ethereum, ethereum 2.0, proof of stake, sharding]"),(0,s.kt)("h2",{id:"slug-learn-comparisons-ethereum-2"},"slug: ../learn-comparisons-ethereum-2"),(0,s.kt)("p",null,"Selendra and Ethereum 2.0 are both sharded blockchain protocols. As such, they provide scalability\nby executing transactions in separate shards and provide a protocol to send messages between shards."),(0,s.kt)("h2",{id:"model"},"Model"),(0,s.kt)("p",null,"The shards in Ethereum 2.0 all have the same state transition function (STF), as in the rules\ngoverning how the blockchain can change state with each block. This STF provides an interface for\nsmart contract execution. Contracts exist on a single shard and can send asynchronous messages\nbetween shards."),(0,s.kt)("p",null,'Likewise, in Selendra, each shard hosts core logic, the shards are executed in parallel, and\nSelendra can send cross-shard asynchronous messages. However, each Selendra shard (in Selendra\nterminology, "',(0,s.kt)("a",{parentName:"p",href:"/docs/learn-parachains"},"parachain"),'") has a unique STF. Applications can exist either\nwithin a single shard or across shards by composing logic. Selendra uses WebAssembly (Wasm) as a\n"meta-protocol". A shard\'s STF can be abstract as long as the validators on Selendra can execute it\nwithin a Wasm environment. Selendra will support smart contracts through parachains. To offer some\nperspective, on Ethereum, smart contracts can call each other synchronously in the same shard and\nasynchronously between shards. On Selendra, smart contracts will be able to call each other\nsynchronously in the same parachain and asynchronously across parachains.'),(0,s.kt)("h2",{id:"architecture"},"Architecture"),(0,s.kt)("h3",{id:"ethereum-20"},"Ethereum 2.0"),(0,s.kt)("p",null,"Ethereum 2.0's main chain is called the Beacon Chain. The primary load on the Beacon Chain is\nattestations, which are votes on the availability of shard data and Beacon Chain validity. Each\nshard in Ethereum 2 is simply a blockchain with the Ethereum Wasm (eWasm) interface."),(0,s.kt)("p",null,"Ethereum 2.0 launched phase 0 of a multi-phase rollout in December 2020, operating in parallel to\nthe legacy Ethereum 1.0 chain:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Phase 0")," provisioned the Beacon Chain, accepting deposits from validators and implementing\nproof-of-stake consensus, eventually among many shards."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Phase 1"),' launches 64 shards as simple chains, to test the Beacon Chain\'s finality. Each shard\nsubmits "crosslinks" to the Beacon Chain, which contains the information to finalize shard data.'),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Phase 1.5")," integrates Eth 1 as a shard to finalize the proof-of-work chain's blocks."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Phase 2")," implements the eWasm interface, phasing out proof-of-work, finally making the system\nusable to end-users. ","[1]")),(0,s.kt)("p",null,"After the launch of the Beacon Chain in phase 0, the roadmap was altered to prioritize the\ntransition of the legacy Ethereum 1.0 chain from Proof-of-Work to Ethereum 2.0's Proof-of-Stake\nconsensus, preceding the rollout of shards on the network. ","[2]"),(0,s.kt)("p",null,'The network will also have "side chains" to interact with chains that are not under the finality\nprotocol of Ethereum 2.0.'),(0,s.kt)("h3",{id:"selendra"},"Selendra"),(0,s.kt)("p",null,"Like Ethereum 2.0, Selendra also has a main chain, called the Relay Chain, with several shards,\ncalled ",(0,s.kt)("a",{parentName:"p",href:"/docs/learn-parachains"},"parachains"),". Parachains are not restricted to a single interface like\neWasm. Instead, they can define their own logic and interface, as long as they provide their STF to\nthe Relay Chain validators so that they can execute it."),(0,s.kt)("p",null,"Selendra, now live as a Relay Chain, only plans to launch the ability to validate up to 20 shards\nper block, gradually scaling up to 100 shards per block. Besides parachains, which are scheduled for\nexecution every block, Selendra also has ",(0,s.kt)("a",{parentName:"p",href:"/docs/learn-parathreads"},"parathreads"),", which are scheduled on\na dynamic basis. This allows chains to share the sharded slots, much like multiple small airlines\nmight share a gate at an airport."),(0,s.kt)("p",null,"In order to interact with chains that want to use their own finalization process (e.g. Bitcoin),\nSelendra has ",(0,s.kt)("a",{parentName:"p",href:"/docs/learn-bridges"},"bridge parachains")," that offer two-way compatibility."),(0,s.kt)("h2",{id:"consensus"},"Consensus"),(0,s.kt)("p",null,"Both Ethereum 2.0 and Selendra use hybrid consensus models where block production and finality each\nhave their own protocol. The finality protocols - Casper FFG for Ethereum 2.0 and GRANDPA for\nSelendra - are both GHOST-based and can both finalize batches of blocks in one round. For block\nproduction, both protocols use slot-based protocols that randomly assign validators to a slot and\nprovide a fork choice rule for unfinalized blocks - RandDAO/LMD for Ethereum 2.0 and BABE for\nSelendra."),(0,s.kt)("p",null,"There are two main differences between Ethereum 2.0 and Selendra consensus:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},'Ethereum 2.0 finalizes batches of blocks according to periods of time called "epochs". The\ncurrent plan is to have 32 blocks per epoch, and finalize them all in one round. With a predicted\nblock time of 12 seconds, this means the expected time to finality is 6 minutes (12 minutes\nmaximum). ',"[3]"," Selendra's finality protocol, GRANDPA, finalizes batches of blocks based on\navailability and validity checks that happen as the proposed chain grows. The time to finality\nvaries with the number of checks that need to be performed (and invalidity reports cause the\nprotocol to require extra checks). The expected time to finality is 12-60 seconds."),(0,s.kt)("li",{parentName:"ol"},"Ethereum 2.0 requires a large number of validators per shard to provide strong validity\nguarantees. Selendra can provide stronger guarantees with fewer validators per shard. Selendra\nachieves this by making validators distribute an erasure coding to all validators in the system,\nsuch that anyone - not only the shard's validators - can reconstruct a parachain's block and test\nits validity. The random parachain-validator assignments and secondary checks performed by\nrandomly selected validators make it impossible for the small set of validators on each parachain\nto collude.")),(0,s.kt)("h2",{id:"staking-mechanics"},"Staking Mechanics"),(0,s.kt)("p",null,'Ethereum 2.0 is a proof-of-stake network that requires 32 ETH to stake for each validator instance.\nValidators run a primary Beacon Chain node and multiple validator clients - one for each 32 ETH.\nThese validators get assigned to "committees", which are randomly selected groups to validate shards\nin the network. Ethereum 2.0 relies on having a large validator set to provide availability and\nvalidity guarantees: They need at least 111 validators per shard to run the network and 256\nvalidators per shard to finalize all shards within one epoch. With 64 shards, that\'s 16_384\nvalidators (given 256 validators per shard). ',"[4][5]"),(0,s.kt)("p",null,"Selendra can provide strong finality and availability guarantees with much fewer validators.\nSelendra uses ",(0,s.kt)("a",{parentName:"p",href:"/docs/learn-staking"},"Nominated Proof of Stake (NPoS)")," to select validators from a\nsmaller set, letting smaller holders nominate validators to run infrastructure while still claiming\nthe rewards of the system, without running a node of their own. Selendra plans to have 1_000\nvalidators by the end of its first year of operation, and needs about ten validators for each\nparachain in the network."),(0,s.kt)("h2",{id:"shards"},"Shards"),(0,s.kt)("p",null,'Every shard in Ethereum 2.0 has the same STF. Each shard will submit "crosslinks" to the beacon\nchain and implement an eWasm execution environment. EWasm is a restricted subset of Wasm for\ncontracts in Ethereum. The eWasm interface provides a set of methods available to contracts. There\nshould be a similar set of development tools like Truffle and Ganache to develop for eWasm. ',"[7]"),(0,s.kt)("p",null,'Every shard in Selendra has an abstract STF based on Wasm. Each shard can expose a custom interface,\nas long as the logic compiles to Wasm and the shard provides an "execute block" function to Selendra\nvalidators. Selendra has the Substrate development framework that allows full spectrum composability\nwith a suite of modules that can be configured, composed, and extended to develop a chain\'s STF.'),(0,s.kt)("h2",{id:"message-passing"},"Message Passing"),(0,s.kt)("p",null,"Shards in Ethereum 2.0 will have access to each other's state via their crosslinks and state proofs.\nIn the model of Ethereum 2.0 with 64 shards, each one posts a crosslink in the Beacon Chain for\nevery block, ","[4]"," meaning that shards could contain logic that executes based on some light client\nproof of a transaction on another shard. ","[8]"," Ethereum 2.0 has not released a specification for which\nnodes pass messages between shards."),(0,s.kt)("p",null,"Selendra uses ",(0,s.kt)("a",{parentName:"p",href:"/docs/learn-xcm"},"Cross-Consensus Message Passing Format (XCM)")," for parachains to send\narbitrary messages to each other. Parachains open connections with each other and can send messages\nvia their established channels. Given that collators will need to be full nodes of the Relay Chain\nas well, they will be connected and will be able to relay messages from parachain A to parachain B..\nMessages do not pass through the Relay Chain, only proofs of post and channel operations (open,\nclose, etc.) go into the Relay Chain. This enhances scalability by keeping data on the edges of the\nsystem."),(0,s.kt)("h2",{id:"governance"},"Governance"),(0,s.kt)("p",null,"Ethereum 2.0 governance is still unresolved. Ethereum currently uses off-chain governance procedures\nlike GitHub discussions, All Core Devs calls, and Ethereum Magicians to make decisions about the\nprotocol. ","[9]"),(0,s.kt)("p",null,"Selendra uses on-chain ",(0,s.kt)("a",{parentName:"p",href:"/docs/learn-governance"},"governance")," with a multicameral system. There are\nseveral avenues to issue proposals, e.g. from the on-chain Council, the Technical Committee, or from\nthe public. All proposals ultimately pass through a public referendum, where the majority of tokens\ncan always control the outcome. For low-turnout referenda, Selendra uses adaptive quorum biasing to\nset the passing threshold. Referenda can cover a variety of topics, including fund allocation from\nan on-chain ",(0,s.kt)("a",{parentName:"p",href:"/docs/learn-treasury"},"Treasury")," or modifying the underlying runtime code of the chain.\nDecisions get enacted on-chain and are binding and autonomous."),(0,s.kt)("h2",{id:"upgrades"},"Upgrades"),(0,s.kt)("p",null,"Upgrades on Ethereum 2.0 will follow the normal hard-fork procedure, requiring validators to upgrade\ntheir nodes to implement protocol changes."),(0,s.kt)("p",null,"Using the Wasm meta-protocol, Selendra can enact chain upgrades and successful proposals without a\nhard fork. Anything that is within the STF, the transaction queue, or off-chain workers can be\nupgraded without forking the chain."),(0,s.kt)("h2",{id:"conclusion"},"Conclusion"),(0,s.kt)("p",null,'Ethereum 2.0 and Selendra both use a sharded model where shard chains ("shards" in Ethereum 2.0 and\n"parachains/parathreads" in Selendra) are secured by a main chain by linking shard state in the\nblocks of the main chains. The two protocols differ in a few main areas. First, all shards in\nEthereum 2.0 has the same STF, while Selendra lets shards have an abstract STF. Second, governance\nprocesses in Ethereum 2.0 are planned to be off-chain and thus require coordination for a hard fork\nto enact governance decisions, while in Selendra the decisions are on-chain and enacted\nautonomously. Third, the validator selection mechanisms are different because Selendra can provide\nstrong availability and validity guarantees with a smaller number of validators per shard.'),(0,s.kt)("h2",{id:"references"},"References"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("a",{parentName:"li",href:"https://docs.ethhub.io/ethereum-roadmap/ethereum-2.0/eth-2.0-phases/"},"Ethereum 2.0 Phases")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("a",{parentName:"li",href:"https://ethereum.org/en/eth2/merge/"},"Ethereum 2.0 Merge")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/ethereum/eth2.0-specs/blob/676e216/specs/phase0/beacon-chain.md#time-parameters"},"Ethereum 2 Block Time")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("a",{parentName:"li",href:"https://docs.ethhub.io/ethereum-roadmap/ethereum-2.0/eth-2.0-economics/"},"Ethereum 2.0 Economics")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("a",{parentName:"li",href:"https://notes.ethereum.org/@vbuterin/HkiULaluS"},"Buterin, Eth2 shard chain simplification proposal")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("a",{parentName:"li",href:"https://messari.io/report/crypto-theses-for-2020"},"Messari Crypto Theses for 2020")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/ewasm/design"},"eWasm Design")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/ethereum/wiki/wiki/Sharding-FAQ#how-would-synchronous-cross-shard-messages-work"},"Sharding FAQ")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/ethereum/wiki/wiki/Governance-compendium"},"Ethereum Governance Compendium"))))}m.isMDXComponent=!0}}]);